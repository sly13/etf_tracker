import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../../shared/prisma/prisma.service';
import TelegramBot from 'node-telegram-bot-api';

export interface ETFNotificationData {
  bitcoinFlow: number;
  ethereumFlow: number;
  bitcoinTotal: number;
  ethereumTotal: number;
  date: string;
  bitcoinData?: any;
  ethereumData?: any;
}

@Injectable()
export class TelegramBotService {
  private readonly logger = new Logger(TelegramBotService.name);
  private bot: TelegramBot;
  private isInitialized = false;

  constructor(
    private configService: ConfigService,
    private prismaService: PrismaService,
  ) {
    this.initializeBot();
  }

  private async initializeBot() {
    const token = this.configService.get<string>('TELEGRAM_BOT_TOKEN');

    if (!token) {
      this.logger.warn(
        '‚ö†Ô∏è TELEGRAM_BOT_TOKEN not found in environment variables',
      );
      return;
    }

    try {
      this.bot = new TelegramBot(token, { polling: true });
      this.setupBotHandlers();
      this.isInitialized = true;
      this.logger.log('‚úÖ Telegram bot initialized and started');
    } catch (error) {
      this.logger.error('‚ùå Error initializing Telegram bot:', error);
    }
  }

  private setupBotHandlers() {
    // /start command with parameters
    this.bot.onText(/\/start(.*)/, async (msg, match) => {
      const chatId = msg.chat.id;
      const userName = msg.from?.first_name || 'User';
      const startParam = match?.[1]?.trim(); // Parameter after /start

      try {
        // –ï—Å–ª–∏ –µ—Å—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä, –ø—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ deviceId
        if (startParam) {
          const userByDeviceId = await this.prismaService.user.findUnique({
            where: { deviceId: startParam },
            include: { application: true },
          });

          if (userByDeviceId) {
            // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º Telegram –∞–∫–∫–∞—É–Ω—Ç –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            await this.prismaService.user.update({
              where: { id: userByDeviceId.id },
              data: {
                telegramChatId: chatId.toString(),
                enableTelegramNotifications: true,
                telegramLinkedAt: new Date(),
                lastUsed: new Date(),
                // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ Telegram, –µ—Å–ª–∏ –æ–Ω–∏ –Ω–µ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã
                firstName:
                  userByDeviceId.firstName ||
                  msg.from?.first_name ||
                  userByDeviceId.firstName,
                lastName:
                  userByDeviceId.lastName ||
                  msg.from?.last_name ||
                  userByDeviceId.lastName,
                language:
                  userByDeviceId.language ||
                  msg.from?.language_code ||
                  userByDeviceId.language,
              },
            });

            const welcomeMessage = `
ü§ñ <b>Welcome to ${userByDeviceId.application.displayName}!</b>

üëã Hello, ${userName}!

üîî <b>Telegram notifications activated!</b>

üì± Application: ${userByDeviceId.application.displayName}
üë§ User: ${userByDeviceId.firstName || 'Not specified'} ${userByDeviceId.lastName || ''}
üÜî Device ID: ${userByDeviceId.deviceId}

üìä You will receive notifications about:
‚Ä¢ Bitcoin ETF flows
‚Ä¢ Ethereum ETF flows
‚Ä¢ Significant flow changes

<i>Use /help to see available commands</i>
            `.trim();

            await this.bot.sendMessage(chatId, welcomeMessage, {
              parse_mode: 'HTML',
            });

            this.logger.log(
              `‚úÖ User ${userName} (${chatId}) automatically linked to deviceId: ${startParam}`,
            );
            return;
          }
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º Telegram Chat ID
        const existingUser = await this.prismaService.user.findUnique({
          where: { telegramChatId: chatId.toString() },
          include: { application: true },
        });

        if (existingUser) {
          // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
          await this.prismaService.user.update({
            where: { id: existingUser.id },
            data: {
              enableTelegramNotifications: true,
              telegramLinkedAt: new Date(),
              lastUsed: new Date(),
            },
          });

          const welcomeMessage = `
ü§ñ <b>Welcome back!</b>

üëã Hello, ${userName}!

üîî <b>Telegram notifications activated!</b>

üìä You will receive notifications about:
‚Ä¢ Bitcoin ETF flows
‚Ä¢ Ethereum ETF flows
‚Ä¢ Significant flow changes

<i>Use /help to see available commands</i>
          `.trim();

          await this.bot.sendMessage(chatId, welcomeMessage, {
            parse_mode: 'HTML',
          });

          this.logger.log(
            `‚úÖ User ${userName} (${chatId}) activated Telegram notifications`,
          );
        } else {
          // User without deviceId - needs to register in the app first
          const linkMessage = `
ü§ñ <b>Welcome to ETF Tracker Bot!</b>

üëã Hello, ${userName}!

üì± To receive notifications, you need to first register in the ETF Flow Tracker application.

üîó <b>How to link Telegram:</b>
1. Open the ETF Flow Tracker application
2. Go to settings
3. Find the "Telegram notifications" section
4. Click "Link Telegram"

<i>After linking, you will receive notifications automatically!</i>
          `.trim();

          await this.bot.sendMessage(chatId, linkMessage, {
            parse_mode: 'HTML',
          });

          this.logger.log(
            `üìù New user ${userName} (${chatId}) received linking instructions`,
          );
        }
      } catch (error) {
        this.logger.error('‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥—ã /start:', error);
      }
    });

    // –ö–æ–º–∞–Ω–¥–∞ /stop
    this.bot.onText(/\/stop/, async (msg) => {
      const chatId = msg.chat.id;
      const userName = msg.from?.first_name || 'User';

      try {
        const user = await this.prismaService.user.findUnique({
          where: { telegramChatId: chatId.toString() },
        });

        if (user) {
          await this.prismaService.user.update({
            where: { id: user.id },
            data: { enableTelegramNotifications: false },
          });

          const stopMessage = `
üîï <b>Telegram notifications disabled</b>

üëã Goodbye, ${userName}!

You will no longer receive Telegram notifications about ETF flows.

<i>Use /start to reactivate</i>
          `.trim();

          await this.bot.sendMessage(chatId, stopMessage, {
            parse_mode: 'HTML',
          });

          this.logger.log(
            `‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${userName} (${chatId}) –æ—Ç–∫–ª—é—á–∏–ª Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è`,
          );
        } else {
          await this.bot.sendMessage(
            chatId,
            '‚ùå –í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ —Å–∏—Å—Ç–µ–º–µ.',
          );
        }
      } catch (error) {
        this.logger.error('‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥—ã /stop:', error);
      }
    });

    // –ö–æ–º–∞–Ω–¥–∞ /status
    this.bot.onText(/\/status/, async (msg) => {
      const chatId = msg.chat.id;

      try {
        const user = await this.prismaService.user.findUnique({
          where: { telegramChatId: chatId.toString() },
          include: { application: true },
        });

        if (user) {
          const statusMessage = `
üìä <b>–°—Ç–∞—Ç—É—Å –∞–∫–∫–∞—É–Ω—Ç–∞</b>

üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: ${user.firstName || '–ù–µ —É–∫–∞–∑–∞–Ω–æ'} ${user.lastName || ''}
üì± –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ: ${user.application.displayName}
üîî Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: ${user.enableTelegramNotifications ? '‚úÖ –í–∫–ª—é—á–µ–Ω—ã' : '‚ùå –û—Ç–∫–ª—é—á–µ–Ω—ã'}
üìä ETF —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: ${user.enableETFUpdates ? '‚úÖ –í–∫–ª—é—á–µ–Ω—ã' : '‚ùå –û—Ç–∫–ª—é—á–µ–Ω—ã'}
üìà –ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è: ${user.enableSignificantFlow ? '‚úÖ –í–∫–ª—é—á–µ–Ω—ã' : '‚ùå –û—Ç–∫–ª—é—á–µ–Ω—ã'}

üìÖ –î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: ${new Date(user.createdAt).toLocaleDateString('ru-RU')}
üîó Telegram –ø—Ä–∏–≤—è–∑–∞–Ω: ${user.telegramLinkedAt ? new Date(user.telegramLinkedAt).toLocaleDateString('ru-RU') : '–ù–µ –ø—Ä–∏–≤—è–∑–∞–Ω'}
üïê –ü–æ—Å–ª–µ–¥–Ω–µ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: ${new Date(user.lastUsed).toLocaleString('ru-RU')}

<i>–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –∏–ª–∏ /stop –¥–ª—è –æ—Ç–∫–ª—é—á–µ–Ω–∏—è</i>
          `.trim();

          await this.bot.sendMessage(chatId, statusMessage, {
            parse_mode: 'HTML',
          });
        } else {
          await this.bot.sendMessage(
            chatId,
            '‚ùå –í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ —Å–∏—Å—Ç–µ–º–µ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.',
          );
        }
      } catch (error) {
        this.logger.error('‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥—ã /status:', error);
      }
    });

    // –ö–æ–º–∞–Ω–¥–∞ /help
    this.bot.onText(/\/help/, async (msg) => {
      const chatId = msg.chat.id;

      const helpMessage = `
üìã <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>

/start - –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è ETF
/stop - –û—Ç–ø–∏—Å–∞—Ç—å—Å—è –æ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
/status - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ø–æ–¥–ø–∏—Å–∫–∏
/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É

üìä <b>–û –±–æ—Ç–µ:</b>
–Ø –æ—Ç–ø—Ä–∞–≤–ª—è—é —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –Ω–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö ETF –ø–æ—Ç–æ–∫–æ–≤:
‚Ä¢ Bitcoin ETF –ø–æ—Ç–æ–∫–∏
‚Ä¢ Ethereum ETF –ø–æ—Ç–æ–∫–∏
‚Ä¢ –ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è (>20%)

üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø—Ä–∏—Ö–æ–¥—è—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏ –ø–æ—è–≤–ª–µ–Ω–∏–∏ –Ω–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö.
      `.trim();

      await this.bot.sendMessage(chatId, helpMessage, {
        parse_mode: 'HTML',
      });
    });

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
    this.bot.on('error', (error) => {
      this.logger.error('‚ùå –û—à–∏–±–∫–∞ Telegram –±–æ—Ç–∞:', error);
    });

    this.bot.on('polling_error', (error) => {
      this.logger.error('‚ùå –û—à–∏–±–∫–∞ polling:', error);
    });
  }

  /**
   * –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤—Å–µ–º –ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º
   */
  async sendETFUpdateNotification(data: ETFNotificationData): Promise<boolean> {
    if (!this.isInitialized) {
      this.logger.warn('‚ö†Ô∏è Telegram –±–æ—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
      return false;
    }

    try {
      // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –≤–∫–ª—é—á–µ–Ω–Ω—ã–º–∏ Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è–º–∏
      const activeUsers = await this.prismaService.user.findMany({
        where: {
          isActive: true,
          enableTelegramNotifications: true,
          telegramChatId: { not: null },
        },
      });

      if (activeUsers.length === 0) {
        this.logger.log(
          'üì± –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è–º–∏',
        );
        return true;
      }

      const message = this.formatETFMessage(data);
      let successCount = 0;
      let errorCount = 0;

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∫–∞–∂–¥–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
      for (const user of activeUsers) {
        try {
          await this.bot.sendMessage(parseInt(user.telegramChatId!), message, {
            parse_mode: 'HTML',
            disable_web_page_preview: true,
          });
          successCount++;
        } catch (error) {
          errorCount++;
          this.logger.warn(
            `‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${user.telegramChatId}:`,
            error.message,
          );

          // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –±–æ—Ç–∞, –æ—Ç–∫–ª—é—á–∞–µ–º Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
          if (error.response?.body?.error_code === 403) {
            await this.prismaService.user.update({
              where: { id: user.id },
              data: { enableTelegramNotifications: false },
            });
            this.logger.log(
              `üö´ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${user.telegramChatId} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –±–æ—Ç–∞, Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç–∫–ª—é—á–µ–Ω—ã`,
            );
          }
        }
      }

      this.logger.log(
        `‚úÖ Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: ${successCount} —É—Å–ø–µ—à–Ω–æ, ${errorCount} –æ—à–∏–±–æ–∫`,
      );
      return successCount > 0;
    } catch (error) {
      this.logger.error('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:', error);
      return false;
    }
  }

  /**
   * –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö
   */
  async sendSignificantFlowNotification(
    type: 'bitcoin' | 'ethereum',
    flow: number,
    previousFlow: number,
  ): Promise<boolean> {
    if (!this.isInitialized) {
      this.logger.warn('‚ö†Ô∏è Telegram –±–æ—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
      return false;
    }

    try {
      const change = flow - previousFlow;
      const changePercent =
        previousFlow !== 0 ? (change / Math.abs(previousFlow)) * 100 : 0;

      const isPositive = change > 0;
      const emoji = isPositive ? 'üìà' : 'üìâ';
      const cryptoName = type === 'bitcoin' ? 'Bitcoin' : 'Ethereum';

      const message = `
${emoji} <b>${cryptoName} ETF - –ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ</b>

${isPositive ? '–ü—Ä–∏—Ç–æ–∫' : '–û—Ç—Ç–æ–∫'}: <b>${Math.abs(change).toFixed(2)}M$</b>
–ò–∑–º–µ–Ω–µ–Ω–∏–µ: <b>${changePercent.toFixed(1)}%</b>
–¢–µ–∫—É—â–∏–π –ø–æ—Ç–æ–∫: <b>${flow.toFixed(2)}M$</b>
–ü—Ä–µ–¥—ã–¥—É—â–∏–π –ø–æ—Ç–æ–∫: <b>${previousFlow.toFixed(2)}M$</b>

<i>${new Date().toLocaleString('ru-RU')}</i>
      `.trim();

      const activeUsers = await this.prismaService.user.findMany({
        where: { isActive: true },
      });

      let successCount = 0;
      for (const user of activeUsers) {
        if (!user.telegramChatId) continue;

        try {
          await this.bot.sendMessage(parseInt(user.telegramChatId), message, {
            parse_mode: 'HTML',
            disable_web_page_preview: true,
          });
          successCount++;
        } catch (error) {
          if (error.response?.body?.error_code === 403) {
            await this.prismaService.user.update({
              where: { telegramChatId: user.telegramChatId },
              data: { isActive: false },
            });
          }
        }
      }

      this.logger.log(
        `‚úÖ Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏ ${type} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: ${successCount} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π`,
      );
      return successCount > 0;
    } catch (error) {
      this.logger.error(
        '‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏:',
        error,
      );
      return false;
    }
  }

  /**
   * –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
   */
  async sendTestNotification(): Promise<boolean> {
    if (!this.isInitialized) {
      this.logger.warn('‚ö†Ô∏è Telegram –±–æ—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
      return false;
    }

    try {
      const message = `
üß™ <b>–¢–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ</b>

ETF Tracker —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ!

<i>${new Date().toLocaleString('ru-RU')}</i>
      `.trim();

      const activeUsers = await this.prismaService.user.findMany({
        where: { isActive: true },
      });

      let successCount = 0;
      for (const user of activeUsers) {
        if (!user.telegramChatId) continue;

        try {
          await this.bot.sendMessage(parseInt(user.telegramChatId), message, {
            parse_mode: 'HTML',
            disable_web_page_preview: true,
          });
          successCount++;
        } catch (error) {
          if (error.response?.body?.error_code === 403) {
            await this.prismaService.user.update({
              where: { telegramChatId: user.telegramChatId },
              data: { isActive: false },
            });
          }
        }
      }

      this.logger.log(
        `‚úÖ Telegram —Ç–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: ${successCount} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π`,
      );
      return successCount > 0;
    } catch (error) {
      this.logger.error(
        '‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ Telegram —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:',
        error,
      );
      return false;
    }
  }

  /**
   * –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ –¥–∞–Ω–Ω—ã—Ö ETF
   */
  private formatETFMessage(data: ETFNotificationData): string {
    const bitcoinFlowText =
      data.bitcoinFlow >= 0
        ? `+${data.bitcoinFlow.toFixed(2)}M$`
        : `${data.bitcoinFlow.toFixed(2)}M$`;

    const ethereumFlowText =
      data.ethereumFlow >= 0
        ? `+${data.ethereumFlow.toFixed(2)}M$`
        : `${data.ethereumFlow.toFixed(2)}M$`;

    const bitcoinEmoji = data.bitcoinFlow >= 0 ? 'üìà' : 'üìâ';
    const ethereumEmoji = data.ethereumFlow >= 0 ? 'üìà' : 'üìâ';

    let message = `
üìä <b>–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ ETF –ø–æ—Ç–æ–∫–æ–≤</b>

${bitcoinEmoji} <b>Bitcoin ETF:</b> ${bitcoinFlowText}
${ethereumEmoji} <b>Ethereum ETF:</b> ${ethereumFlowText}

<b>–û–±—â–∏–µ –∏—Ç–æ–≥–∏:</b>
üí∞ Bitcoin: ${data.bitcoinTotal.toFixed(2)}M$
üí∞ Ethereum: ${data.ethereumTotal.toFixed(2)}M$

<i>${new Date().toLocaleString('ru-RU')}</i>
    `.trim();

    // –î–æ–±–∞–≤–ª—è–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –µ—Å–ª–∏ –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ
    if (data.bitcoinData || data.ethereumData) {
      message += '\n\n<b>–î–µ—Ç–∞–ª–∏ –ø–æ —Ñ–æ–Ω–¥–∞–º:</b>\n';

      if (data.bitcoinData) {
        message += '\n<b>Bitcoin ETF:</b>\n';
        const btcFunds = this.formatFundDetails(data.bitcoinData);
        message += btcFunds;
      }

      if (data.ethereumData) {
        message += '\n<b>Ethereum ETF:</b>\n';
        const ethFunds = this.formatFundDetails(data.ethereumData);
        message += ethFunds;
      }
    }

    return message;
  }

  /**
   * –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–µ—Ç–∞–ª–µ–π –ø–æ —Ñ–æ–Ω–¥–∞–º
   */
  private formatFundDetails(fundData: any): string {
    const funds: string[] = [];

    if (fundData.blackrock && fundData.blackrock !== 0) {
      funds.push(`BlackRock: ${fundData.blackrock.toFixed(2)}M$`);
    }
    if (fundData.fidelity && fundData.fidelity !== 0) {
      funds.push(`Fidelity: ${fundData.fidelity.toFixed(2)}M$`);
    }
    if (fundData.bitwise && fundData.bitwise !== 0) {
      funds.push(`Bitwise: ${fundData.bitwise.toFixed(2)}M$`);
    }
    if (fundData.twentyOneShares && fundData.twentyOneShares !== 0) {
      funds.push(`21Shares: ${fundData.twentyOneShares.toFixed(2)}M$`);
    }
    if (fundData.vanEck && fundData.vanEck !== 0) {
      funds.push(`VanEck: ${fundData.vanEck.toFixed(2)}M$`);
    }
    if (fundData.invesco && fundData.invesco !== 0) {
      funds.push(`Invesco: ${fundData.invesco.toFixed(2)}M$`);
    }
    if (fundData.franklin && fundData.franklin !== 0) {
      funds.push(`Franklin: ${fundData.franklin.toFixed(2)}M$`);
    }
    if (fundData.grayscale && fundData.grayscale !== 0) {
      funds.push(`Grayscale: ${fundData.grayscale.toFixed(2)}M$`);
    }
    if (fundData.valkyrie && fundData.valkyrie !== 0) {
      funds.push(`Valkyrie: ${fundData.valkyrie.toFixed(2)}M$`);
    }
    if (fundData.wisdomTree && fundData.wisdomTree !== 0) {
      funds.push(`WisdomTree: ${fundData.wisdomTree.toFixed(2)}M$`);
    }
    if (fundData.grayscaleEth && fundData.grayscaleEth !== 0) {
      funds.push(`Grayscale ETH: ${fundData.grayscaleEth.toFixed(2)}M$`);
    }
    if (fundData.grayscaleBtc && fundData.grayscaleBtc !== 0) {
      funds.push(`Grayscale BTC: ${fundData.grayscaleBtc.toFixed(2)}M$`);
    }

    return funds.length > 0 ? funds.join('\n') : '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö';
  }

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
   */
  async getUserStats(): Promise<{
    total: number;
    active: number;
    inactive: number;
  }> {
    try {
      const [total, active] = await Promise.all([
        this.prismaService.user.count(),
        this.prismaService.user.count({
          where: { isActive: true },
        }),
      ]);

      return {
        total,
        active,
        inactive: total - active,
      };
    } catch (error) {
      this.logger.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:', error);
      return { total: 0, active: 0, inactive: 0 };
    }
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–æ—Ç–∞
   */
  isBotInitialized(): boolean {
    return this.isInitialized;
  }
}
